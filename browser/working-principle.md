# 浏览器工作原理

## 概览

快速响应的网站提供更好的用户体验。用户期待内容快速加载和流畅交互的 Web 体验。

导致 Web 性能问题的原因主要有两种，一是网络延迟，二是大部分情况下的浏览器单线程执行。

保障页面快速加载的最大威胁是网络延迟。开发者的目标是使网站加载速度尽可能快，或者至少看起来加载速度很快，以便用户尽快获取所需信息。网络延迟是将字节传输到计算机的时间。Web 性能优化需要做的就是使页面尽可能快地加载完成。

大部分情况下，浏览器被认为是单线程的。也就是说，它们在执行一个任务之前会从头到尾完成一个任务，然后才会接受另一个任务。为了实现流畅的交互，开发者的目标是确保网站的交互性能良好，从流畅的滚动到对触摸的响应。渲染时间非常关键，我们需要确保主线程能够完成交给它的所有工作，并且始终能够处理用户交互。通过理解浏览器的单线程特性，并尽可能和适当地减少主线程的责任，可以提高网页性能，以确保渲染流畅，并且对交互的响应是即时的。

## 导航（ DNS 查询 ）

导航是加载 web 页面的第一步。Web 性能优化的目标之一就是缩短导航完成所花费的时间，在理想情况下，它通常不会花费太多的时间，但是网络延迟和带宽会让它变久。

1. 发起请求
   当你在浏览器中输入一个域名（例如`www.example.com`）并按下回车时，DNS 查询过程就开始了。你的设备（称为“客户端”）需要找到这个域名对应的 IP 地址，以便与目标服务器建立连接。
2. 检查本地缓存

   - 操作系统缓存：首先，客户端会检查操作系统的 DNS 缓存（例如 Windows 的 hosts 文件或系统的缓存）。如果之前访问过这个域名且缓存未过期，系统会直接返回缓存中的 IP 地址。
   - 浏览器缓存：现代浏览器（如 Chrome、Firefox）也会维护自己的 DNS 缓存。如果缓存中有匹配的记录，查询到此结束。
     如果本地缓存中没有记录，查询会继续。

3. 请求本地 DNS 解析器（递归解析器）
   客户端会将查询请求发送到本地 DNS 解析器（也叫递归解析器）。这个解析器通常由你的互联网服务提供商（ISP）提供，或者你手动配置的公共 DNS 服务（如 Google 的 8.8.8.8 或 Cloudflare 的 1.1.1.1）。
   递归解析器的任务是为客户端完成整个查询过程，并返回最终的 IP 地址。它会从头到尾处理查询，因此客户端无需直接与外部 DNS 服务器交互。
4. 检查递归解析器的缓存
   递归解析器收到请求后，会先检查自己的缓存。如果它之前已经解析过`www.example.com`且记录未过期（由 TTL，即“生存时间”决定），它会直接返回 IP 地址给客户端，查询结束。
   如果缓存中没有记录，递归解析器会启动外部查询。
5. 根域名服务器（Root Servers）
   递归解析器从根域名服务器开始查询。根服务器是 DNS 体系的顶层，全球有 13 组（由 A 到 M 标记，例如 a.root-servers.net），由 ICANN 管理。

   - 递归解析器发送请求：“请告诉我`www.example.com`的 IP 地址。”
   - 根服务器不会直接知道具体 IP，但它知道顶级域名（TLD，如.com、.org）的服务器地址。它会返回一个响应：“我不知道具体 IP，但你可以去问.com TLD 服务器。”

   根服务器的地址通常预配置在递归解析器中，因此这一步不需要额外查询。

6. 顶级域名服务器（TLD Servers）
   递归解析器根据根服务器的指引，向对应的顶级域名服务器（TLD 服务器）发送查询。以`www.example.com`为例，它会联系.com TLD 服务器。

   - 请求：“请告诉我`www.example.com`的 IP 地址。”
   - TLD 服务器也不知道具体 IP，但它知道 example.com 这个域名的权威名称服务器（Authoritative Name Server）。它会返回：“去问 example.com 的权威服务器吧，这是它们的地址。”

7. 权威名称服务器（Authoritative Name Servers）
   递归解析器接着联系 example.com 域名的权威名称服务器。这些服务器由域名所有者或其 DNS 服务提供商（如 Cloudflare、AWS Route 53）维护，存储了该域名及其子域名的实际 DNS 记录。

   - 请求：“请告诉我`www.example.com`的 IP 地址。”
   - 权威服务器查找其记录（通常是一个 A 记录或 AAAA 记录，分别对应 IPv4 和 IPv6 地址），然后返回：“`www.example.com`的 IP 是`192.0.2.1`。”

8. 返回结果并缓存

   - 递归解析器收到权威服务器的响应（例如 192.0.2.1），将其缓存下来（根据 TTL 时间），以便下次查询时无需重复整个过程。
   - 然后，递归解析器将这个 IP 地址返回给客户端。

9. 客户端连接目标服务器
   客户端（你的设备）拿到 IP 地址后，通过网络协议（如 TCP/IP）与目标服务器（192.0.2.1）建立连接。这时，浏览器就可以加载网页内容了。

### DNS 查询类型

### **1. 递归查询（Recursive Query）**

#### **定义**

在递归查询中，DNS 客户端要求 DNS 服务器（通常是递归解析器）完全负责解析请求的域名，并返回最终结果。递归解析器要么返回所请求的资源记录（如 IP 地址），要么在无法找到记录时返回错误消息。

#### **工作原理**

- **客户端角色**：客户端只需发起一次查询，之后将所有解析任务交给递归解析器。
- **递归解析器角色**：
  1. 接收客户端的查询请求（如解析 `www.example.com`）。
  2. 检查本地缓存是否有该记录。
  3. 如果缓存中没有，则从根服务器开始，逐步查询整个 DNS 层级，直到找到目标记录或确认记录不存在。
  4. 将最终结果（IP 地址或错误）返回给客户端。
- **例子**：
  - 客户端查询 `www.example.com`。
  - 递归解析器依次联系：
    - 根服务器（`.`）→ 返回 `.com` 的顶级域名服务器地址。
    - `.com` 顶级域名服务器 → 返回 `example.com` 的权威服务器地址。
    - `example.com` 权威服务器 → 返回 `www.example.com` 的 IP 地址。
  - 最后，递归解析器将 IP 地址返回给客户端。

#### **关键特点**

- **客户端简单**：只需一次查询，解析器承担所有后续工作。
- **服务器负担重**：递归解析器需要完成整个查询链，消耗更多资源。
- **典型场景**：家庭网络或企业网络中的终端设备（如电脑、手机）通常使用递归查询，依赖 ISP 的 DNS 服务器。

---

### **2. 迭代查询（Iterative Query）**

#### **定义**

在迭代查询中，DNS 客户端允许 DNS 服务器返回其能提供的最佳答案。如果服务器不知道完整答案，它会返回一个指向更接近答案的 DNS 服务器的引用（Referral）。客户端需要根据这些引用逐步查询，直到找到最终记录或失败。

#### **工作原理**

- **客户端角色**：客户端主动发起多次查询，逐步逼近目标。
- **服务器角色**：每次只返回当前已知的“最佳答案”，通常是一个指向更低级别权威服务器的地址。
- **例子**：
  - 客户端查询 `www.example.com`：
    1. 问本地 DNS 服务器，本地服务器无记录，返回根服务器地址。
    2. 客户端问根服务器，根服务器返回 `.com` 顶级域名服务器地址。
    3. 客户端问 `.com` 服务器，返回 `example.com` 的权威服务器地址。
    4. 客户端问 `example.com` 权威服务器，得到 `www.example.com` 的 IP 地址。
- **查询链**：客户端自己沿着这条链走下去，直到解析完成或超时/出错。

#### **关键特点**

- **客户端复杂**：需要多次发起查询，处理引用逻辑。
- **服务器负担轻**：每个服务器只负责回答自己知道的部分，不参与完整解析。
- **典型场景**：递归解析器在与权威服务器交互时，内部通常使用迭代查询，而不是再次递归。

---

### **3. 非递归查询（Non-Recursive Query）**

#### **定义**

非递归查询发生在 DNS 客户端查询一个 DNS 服务器时，该服务器要么对请求的记录具有权威性（即直接管理该域名），要么该记录已存在于其缓存中。服务器直接返回答案，无需进一步查询其他服务器。

#### **工作原理**

- **客户端角色**：发起查询，期待立即得到完整答案。
- **服务器角色**：
  1. 检查自己是否是所查询域名的权威服务器，或者缓存中是否有记录。
  2. 如果有，直接返回记录；如果没有，返回错误或空响应。
- **例子**：
  - 客户端查询 `www.example.com`，直接问 `example.com` 的权威服务器。
  - 权威服务器返回 `www.example.com` 的 IP 地址，无需再查其他服务器。
  - 或者，本地 DNS 服务器缓存了 `www.example.com` 的记录，直接返回缓存结果。

#### **关键特点**

- **高效**：只需一次查询，响应速度快。
- **前提**：服务器必须有权威性或缓存记录。
- **典型场景**：缓存命中时（如访问热门网站），或客户端直接查询权威服务器。

#### **缓存的作用**

- DNS 服务器通常会缓存查询结果（基于 TTL，Time To Live），减少对上游服务器的请求。
- 缓存是非递归查询高效的重要原因，也降低了网络带宽消耗和权威服务器的负载。

---

### **三者的对比与联系**

| **特性**       | **递归查询**            | **迭代查询**           | **非递归查询**     |
| -------------- | ----------------------- | ---------------------- | ------------------ |
| **客户端负担** | 低（一次查询）          | 高（多次查询）         | 低（一次查询）     |
| **服务器负担** | 高（完整解析）          | 低（只提供引用）       | 低（直接回答）     |
| **查询次数**   | 客户端 1 次，解析器多次 | 客户端多次             | 客户端 1 次        |
| **典型发起者** | 终端用户设备            | 递归解析器内部         | 客户端或缓存命中   |
| **结果**       | 完整记录或错误          | 最佳答案（可能是引用） | 权威记录或缓存记录 |

#### **协作关系**

- **实际解析过程**：当用户通过浏览器访问网站时，通常是这样的：
  1. 浏览器发起**递归查询**给本地递归解析器。
  2. 递归解析器使用**迭代查询**与根服务器、顶级域名服务器、权威服务器交互。
  3. 如果某个服务器的缓存命中或具有权威性，则返回**非递归查询**的结果。
- **分工明确**：递归查询让客户端省心，迭代查询让服务器分工协作，非递归查询优化效率。

## TCP 握手

一旦获取到服务器 IP 地址，浏览器就会通过 TCP“三次握手”与服务器建立连接。这个机制的是用来让两端尝试进行通信——在浏览器和服务器通过上层协议 HTTPS 发送数据之前，可以协商网络 TCP 套接字连接的一些参数。

TCP 的“三次握手”技术经常被称为“SYN-SYN-ACK”——更确切的说是 SYN、SYN-ACK、ACK——因为通过 TCP 首先发送了三个消息进行协商，然后在两台电脑之间开始一个 TCP 会话。是的，这意味着当请求尚未发出的时候，终端与每台服务器之间还要来回多发送三条消息。

## TLS 协商

对于通过 HTTPS 建立的安全连接，还需要另一次 "握手"。TLS 连接是通过一个称为 TLS 握手的流程启动的。当用户导航到一个使用 TLS 的网站时，用户设备（也称为客户端设备）和 Web 服务器之间开始 TLS 握手。

在 TLS 过程中，用户设备和 Web 服务器：

- 指定将要使用的 TLS 版本（TLS 1.0、1.2、1.3 等）
- 决定将要使用哪些密码套件（见下文）
- 使用服务器的 TLS 证书验证服务器的身份
- 握手完成后，生成会话密钥用于加密两者之间的消息

TLS 握手为每个通信会话建立一个密码套件。密码套件是一组算法，其中指定了一些细节，例如哪些共享加密密钥（即会话密钥）将用于该特定会话。TLS 也能在一个未加密的通道上设置匹配的会话密钥，这要归功于一种称为公钥加密的技术。

握手还处理身份验证，其中通常包括服务器向客户端证明其身份。这是通过使用公钥来完成的。公钥是使用单向加密的加密密钥，即任何拥有公钥的人都可以解读使用服务器私钥加密的数据，以确保其真实性，但只有源发送方才可以使用私钥加密数据。服务器的公钥是其 TLS 证书的一部分。

数据完成加密和验明身份后，使用消息身份验证码（MAC）进行签名。接收方然后可以验证 MAC 来确保数据的完整性。

### 性能影响

TLS 的最新版本对 Web 应用的性能几乎没有任何影响。  
由于建立 TLS 连接涉及到的复杂过程，因此必须花费一些加载时间和计算能力。在传输任何数据之前，客户端和服务器必须来回通信几次，这将占用 Web 应用宝贵的几毫秒加载时间，以及客户端和服务器的一些内存。  
然而，目前已有技术帮助缓解 TLS 握手造成的延迟。其一是 TLS 虚假启动（False Start），让服务器和客户端在 TLS 握手完成前开始传输数据。另一种加速 TLS 的技术是 TLS 会话恢复，允许之前通信过的客户端和服务器简化握手过程。  
这些改良帮助 TLS 成为一种非常快速的协议，不会明显影响加载时间。至于与 TLS 相关的计算成本，以今天的标准来看几乎可以忽略不计。  
2018 年发布的 TLS 1.3 进一步提高了 TLS 的速度。TLS 1.3 中的 TLS 握手仅需要一次往返（即来回通信），而不是以前的两次，将握手过程所需时间缩短了几毫秒。如果用户以前已连接过网站，TLS 握手的往返次数为零，从而进一步加快了速度。

![TLS 1.3](./TLS_comparison.png)

## 响应

一旦我们建立了和 web 服务器的连接，浏览器就会代表用户发送一个初始的 HTTP GET 请求，对于网站来说，这个请求通常是一个 HTML 文件。一旦服务器收到请求，它将使用相关的响应头和 HTML 的内容进行回复。
初始请求的响应包含所接收数据的第一个字节。首字节时间（TTFB）是用户通过点击链接进行请求与收到第一个 HTML 数据包之间的时间。第一个内容分块通常是 14KB 的数据。

### 拥塞控制 / TCP 慢启动

在传输过程中，TCP 包被分割成段。由于 TCP 保证了数据包的顺序，因此服务器在发送一定数量的分段后，必须从客户端接收一个 ACK 包的确认。

如果服务器在发送每个分段之后都等待 ACK，那么客户端将频繁地发送 ACK，并且可能会增加传输时间，即使在网络负载较低的情况下也是如此。

另一方面，一次发送过多的分段会导致在繁忙的网络中客户端无法接收分段并且长时间地只会持续发送 ACK，服务器必须不断重新发送分段的问题。

为了平衡传输分段的数量，TCP 慢启动算法用于逐渐增加传输数据量，直到确定最大网络带宽，并在网络负载较高时减少传输数据量。

传输段的数量由拥塞窗口（CWND）的值控制，该值可初始化为 1、2、4 或 10 MSS（以太网协议中的 MSS 为 1500 字节）。该值是发送的字节数，客户端收到后必须发送 ACK。

如果收到 ACK，那么 CWND 值将加倍，这样服务器下次就能发送更多的数据分段。相反，如果没有收到 ACK，那么 CWND 值将减半。因此，这种机制在发送过多分段和过少分段之间取得了平衡。

## 解析

一旦浏览器收到第一个数据分块，它就可以开始解析收到的信息。“解析”是浏览器将通过网络接收的数据转换为 DOM 和 CSSOM 的步骤，通过渲染器在屏幕上将它们绘制成页面。

即使请求页面的 HTML 大于初始的 14KB 数据包，浏览器也将根据其拥有的数据开始解析并尝试渲染。这就是为什么在前 14KB 中包含浏览器开始渲染页面所需的所有内容，或者至少包含页面模板（第一次渲染所需的 CSS 和 HTML）对于 web 性能优化来说是重要的。但是在渲染到屏幕上面之前，HTML、CSS、JavaScript 必须被解析完成。

### 14KB 的依据

“14KB”依据来源于早期 Web 性能优化领域的经验规则，具体与 TCP 网络传输的初始拥塞窗口（Initial Congestion Window，简称 Initial CWND）和浏览器行为有关。

1. 在 TCP 协议中，数据传输采用“慢启动”（Slow Start）机制。发送方（如服务器）一开始不会一次性发送大量数据，而是从一个较小的初始拥塞窗口（Initial CWND）开始，逐步增加发送的数据量。在早期的互联网标准中（如 RFC 2581，1999 年），TCP 的初始拥塞窗口被建议设置为 2-4 个 MSS（Maximum Segment Size，最大分段大小）。MSS 通常由网络的最大传输单元（MTU）决定，默认情况下是以太网的 MTU 为 1500 字节，去掉 TCP 和 IP 头部（约 40 字节），MSS 约为 1460 字节。因此，初始拥塞窗口大约是 2 × 1460 = 2920 字节（约 3KB）到 4 × 1460 = 5840 字节（约 6KB）。

2. 在实际的 HTTP 请求中，浏览器通常在一个 TCP 连接的第一个往返（RTT，Round-Trip Time）中接收服务器返回的数据。这个数据量受限于初始拥塞窗口。为了提高性能，Web 优化专家（如 Steve Souders）在 2000 年代提出，服务器应该在第一个数据包中返回足够多的内容，让浏览器可以开始解析和渲染页面。当时的经验值逐渐演变为 14KB，因为：

   - 随着网络优化，初始拥塞窗口逐渐被调大到 10 个 MSS（约 14KB），特别是在 Google 的推动下（详见后文）。
   - 14KB 被认为是一个合理的折中值，既能容纳关键的 HTML 和 CSS，又不会超过大多数网络环境的初始传输能力。

3. 浏览器的确可以在接收到第一个数据分块后开始解析 HTML（增量解析），而无需等待整个响应完成。14KB 的经验规则源于这样一个假设：如果前 14KB 包含关键渲染路径所需的内容（HTML 结构和关键 CSS），浏览器就能尽早开始构建 DOM 和 CSSOM，从而减少“首次渲染时间”（First Contentful Paint, FCP）。

### 具体计算依据

1. 初始拥塞窗口的演变：
   在 2010 年，Google 提出了将初始拥塞窗口从 4 MSS 增加到 10 MSS 的建议（RFC 6928，2013 年正式标准化）。这意味着初始窗口从 6KB 左右增加到 10 × 1460 = 14,600 字节，约 14KB。
   14KB 因此成为 Web 性能优化中的一个关键数字，因为它代表了服务器在第一个 RTT 中可以无延迟发送的最大数据量。
2. HTTP 头部开销：
   HTTP 响应包括响应头（通常几百字节）和响应体。假设头部占用 400 字节，剩余约 14KB 可用于 HTML、CSS 等内容。
3. 浏览器缓冲区：
   浏览器通常会缓冲一定量的数据后再开始解析。14KB 接近早期浏览器的缓冲区大小，确保解析器有足够的数据开始工作。

浏览器的渲染过程需要 HTML（构建 DOM）、CSS（构建 CSSOM）和可能的 JavaScript。如果这些关键资源能在第一个数据包（14KB）内交付，浏览器可以更快地完成首次渲染。
如果 HTML 超过 14KB，浏览器可能需要额外的 RTT 来接收剩余数据，延迟渲染。
