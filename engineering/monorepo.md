# Monorepo 架构实践

## 引言

Monorepo​（单一代码库）是一种软件开发策略，指的是将多个项目或模块的代码存储在一个单一的版本控制仓库中。与之相对的是 ​Multirepo​（多代码库），即每个项目或模块都有自己独立的代码库。

## 演进

1. 初期阶段：Multirepo

   - 每个项目或模块都有自己的独立代码库。
   - 适用于小型团队或简单项目，管理起来相对简单。

2. 中期阶段：共享代码库

   - 随着项目复杂度的增加，多个项目之间可能共享一些公共代码或库。
   - 此时可能会通过包管理器（如 npm、yarn、pip 等）来共享代码，但这可能导致依赖管理和版本控制复杂化。

3. 后期阶段：Monorepo

   - 为了解决共享代码和依赖管理的问题，团队可能会选择将所有相关项目或模块迁移到一个单一的代码库中。
   - 使用工具（如 Lerna、Nx、Bazel 等）来管理 Monorepo 中的依赖、构建和发布流程。

## 优劣势

### 优势

1. 代码共享与重用
   多个项目或模块可以轻松共享公共代码，减少重复劳动。

2. 简化依赖管理
   所有依赖项都在同一个代码库中，避免了跨仓库的依赖管理问题。

3. 统一的构建和测试
   可以统一配置构建和测试流程，确保所有项目或模块的一致性。

4. 原子提交
   可以一次性提交多个项目或模块的更改，确保跨项目的更改是原子性的。

5. 更好的代码审查
   代码审查者可以在一个地方查看所有相关更改，提高审查效率。

### 劣势

1. 代码库规模大
   随着项目数量的增加，代码库会变得非常庞大，可能导致克隆和操作速度变慢。
   ​
2. 复杂的权限管理
   在大型团队中，管理不同项目或模块的访问权限可能会变得复杂。
   ​
3. 构建和测试时间增加
   由于所有项目或模块都在一个代码库中，构建和测试的时间可能会显著增加。
   ​
4. 学习曲线
   使用 Monorepo 需要学习和掌握新的工具和流程，可能需要一定的学习成本。

## 使用场景

- ​ 多个项目共享大量代码
  如果多个项目之间有大量的共享代码或库，使用 Monorepo 可以简化代码共享和依赖管理。
  ​
- 需要跨项目原子提交
  如果需要在多个项目之间进行原子性的更改，Monorepo 可以确保所有更改一次性提交。
  ​
- 统一构建和测试流程
  如果需要统一配置构建和测试流程，确保所有项目或模块的一致性，Monorepo 是一个不错的选择。
  ​
- 团队规模较大
  在大型团队中，使用 Monorepo 可以简化代码审查和协作流程。

Monorepo 是一种适用于复杂项目和大型团队的开发策略，它简化了代码共享、依赖管理和构建流程，但也带来了代码库规模大、权限管理复杂等挑战。在决定是否使用 Monorepo 时，需要根据项目的具体需求和团队的规模进行权衡。

## 技术选型

### why pnpm?

| 特性               | npm                                    | Yarn                                   | pnpm                                   |
| ------------------ | -------------------------------------- | -------------------------------------- | -------------------------------------- |
| **磁盘空间效率**   | 每个子包复制依赖，占用大量磁盘空间     | 每个子包复制依赖，占用大量磁盘空间     | 使用硬链接和符号链接，显著减少磁盘占用 |
| **安装速度**       | 较慢，尤其是在依赖较多时               | 较快，但不如 `pnpm`                    | 最快，避免重复下载和复制依赖           |
| **依赖隔离性**     | 依赖可能共享，导致冲突                 | 依赖可能共享，导致冲突                 | 严格隔离，避免依赖冲突                 |
| **一致性**         | 使用 `package-lock.json`，可能不够灵活 | 使用 `yarn.lock`，某些情况下不一致     | 使用 `pnpm-lock.yaml`，更简洁可靠      |
| **Monorepo 支持**  | 功能较新，成熟度较低                   | 支持 workspace，但依赖提升可能导致问题 | 功能成熟，提供丰富命令（如 `pnpm -r`） |
| **生态兼容性**     | 默认包管理工具，生态成熟               | 生态成熟，但 Yarn Berry 引入复杂性     | 兼容 `npm` 和 `Yarn` 生态              |
| **开发者体验**     | CLI 功能基本，输出不够直观             | CLI 功能丰富，但某些场景不够直观       | CLI 简洁，输出清晰，开发者体验更好     |
| **社区和未来发展** | 稳定，但缺乏创新                       | 成熟，但 Yarn Berry 方向复杂           | 社区快速增长，代表未来趋势             |

在 workspace 场景下，pnpm 在磁盘空间效率、安装速度、依赖隔离性、一致性、monorepo 支持、生态兼容性、开发者体验和未来发展等方面均表现最佳，因此 ​ 选择 pnpm 作为 workspace 的包管理工具是最佳选择。

### why Turborepo?

在引入 ​Monorepo​ 时，Nx 和 Turborepo 是两个非常流行的工具。虽然 Nx 在功能和性能上表现出色，但 Turborepo 也有其独特的优势，尤其是对于初学者和中小型项目来说。以下是选择 Turborepo 的主要原因：

1. ​ 上手简单
   ​Turborepo​ 的设计理念是简单易用，它的配置文件和命令都非常直观，开发者可以快速上手。
   ​Nx​ 的功能非常丰富，但也因此带来了更高的学习曲线，配置文件复杂，文档阅读起来也较为困难。

2. ​ 社区增长迅速
   ​Turborepo​ 的下载量在一年内从几十万增长到 140 万，社区增长速度非常快，说明它正在被越来越多的开发者接受和使用。
   ​Nx​ 虽然下载量更高（每周约 400 万），但 Turborepo 的快速崛起表明它在未来可能会成为主流工具之一。

3. ​ 性能表现优秀
   ​Turborepo​ 在任务执行速度上表现出色，虽然 Nx 在某些 benchmark 中更快，但 Turborepo 的性能已经足够满足大多数项目的需求。
   ​Turborepo​ 通过缓存和并行化任务来优化构建和开发流程，显著提升了本地开发和 CI 的效率。

4. ​ 轻量级设计
   ​Turborepo​ 的设计非常轻量，专注于核心功能（如任务管理和缓存），没有过多的复杂功能。
   ​Nx​ 功能丰富，但也因此显得臃肿，对于中小型项目来说可能有些过度设计。

5. ​ 与现有工具集成
   ​Turborepo​ 与现有的工具链（如 npm、Yarn、pnpm）无缝集成，无需额外的配置。
   ​Nx​ 虽然也支持多种工具，但在集成上可能需要更多的配置和调整。

6. ​ 文档和开发者体验
   ​Turborepo​ 的文档简洁明了，开发者可以快速找到所需的信息。
   ​Nx​ 的文档虽然全面，但由于功能复杂，阅读起来可能会感到吃力。

7. ​ 灵活性和扩展性
   ​Turborepo​ 提供了足够的灵活性，可以根据项目需求进行定制，同时它的插件系统也支持扩展功能。
   ​Nx​ 虽然功能更丰富，但对于中小型项目来说，可能并不需要如此复杂的扩展性。

8. ​ 更适合中小型项目
   ​Turborepo​ 的设计更偏向于中小型项目，它提供了一种简单而高效的方式来管理 Monorepo。
   ​Nx​ 更适合大型企业级项目，但对于中小型项目来说，可能会显得过于复杂。

**总结**：如果你正在考虑引入 ​Monorepo，Turborepo 是一个非常好的起点，尤其适合中小型项目和初次接触 Monorepo 的开发者。它的简单易用、快速上手、优秀性能和轻量级设计使其成为一个非常有吸引力的选择。
当然，如果你的项目对性能有极致要求，或者需要更复杂的功能，Nx 也是一个值得考虑的工具。但对于大多数场景来说，Turborepo 已经足够强大和灵活，能够满足你的需求。

<!-- ## Monorepo 实战

1. 全局安装 turbo `pnpm install turbo --global`
2. 使用 turborepo 文档的命令初始化项目 `pnpm dlx create-turbo@latest` , 选择`pnpm`作为包管理工具
   - 也可以从 turborepo 提供的示例项目开始 `pnpm dlx create-turbo@latest --example [example-name]` ,比如`with-tailwind`适用于喜欢使用`tailwind`的开发者 , 详见[文档](https://turbo.build/repo/docs/getting-started/examples)
3. 这里以`tailwind`模版为例 -->
